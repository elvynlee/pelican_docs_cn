关于Pelican的一些历史
##########################

.. warning::

    此页面来自原作者（AlexisMétaireau）在2010年12月编写Pelican后撰写的报告。
    这些信息可能不是最新的。

Pelican是一个简单的静态博客生成器。 
它解析标记语言文件（目前支持Markdown和reStructuredText），然后生成包含所有相关文件的HTML文件夹。 
我选择使用Python来实现Pelican，因为它似乎很简单并且符合我的需求。 
我不想为每件事定义一个类，但仍然想让它们之间能松散耦合。事实证明，这正是我想要的。 
感谢一些用户不时的反馈，我能花较少的时间来修复它。 
到目前为止，我已经将Pelican代码重构了两次；每次花费不到30分钟。

用例
========

我之前使用的是WordPress，一种可以在Web服务器上托管的来管理你的博客的解决方案。 
大多数时候，我更喜欢使用Markdown或reStructuredText等标记语言来写文章。 
所以我写文章都是用vim。 我认为能够让人们选择他们偏好的工具来写文章很重要。 
在我看来，一个博客管理系统应该允许你采取任何形式的输入并能将其转换为博客。 这就是Pelican所做的。 
你可以使用你想用的工具和标记语言编写文章，然后生成静态HTML博客。

.. image:: https://docs.getpelican.com/en/stable/_images/overall.png

为了足够灵活，Pelican支持模板，因此你可以根据需要轻松编写自己的主题。

设计过程
==============

Pelican来自我的需要。 我首先创建了一个文件应用程序，然后使它不断成长，成长为支持它现在能做的事情。
要开始，我写了一篇关于我想做什么的文档。然后，我写了点要用来解析的内容（reStructuredText文件）
并开始尝试编写相应代码。 Pelican第一次可用时代码只有200行，其中包含大约10个函数和一个类。

我一直面临不同的问题，而且在使用Pelican时一直想给它添加功能。 
我做的第一个更改是添加支持设置文件。虽然可以用选项参数传递给命令行来设置，但如果选项有很多时，这种方式会变得很乏味。 
同样，随着时间的推移我陆续添加了支持其他不同内容：Atom订阅源，多主题，多种标记语言支持等。
在某些时候，似乎“只有一个文件”的口头禅对于Pelican来说还不够好，
所以 我决定重做一切，并将其拆分为多个不同的文件。

我已经将逻辑分离到不同的类和概念中:

* *writers* are responsible of all the writing process of the files.
  They are responsible of writing .html files, RSS feeds and so on. Since those
  operations are commonly used, the object is created once, and then passed to
  the generators.

* *readers* are used to read from various formats (Markdown and
  reStructuredText for now, but the system is extensible). Given a file, they
  return metadata (author, tags, category, etc) and content (HTML formatted).

* *generators* generate the different outputs. For instance, Pelican
  comes with an ArticlesGenerator and PagesGenerator, into others. Given a
  configuration, they can do whatever you want them to do. Most of the time
  it's generating files from inputs (user inputs and files).

I also deal with contents objects. They can be ``Articles``, ``Pages``,
``Quotes``, or whatever you want. They are defined in the ``contents.py``
module and represent some content to be used by the program.

In more detail
==============

Here is an overview of the classes involved in Pelican.

.. image:: _static/uml.jpg

The interface does not really exist, and I have added it only to clarify the
whole picture. I do use duck typing and not interfaces.

Internally, the following process is followed:

* First of all, the command line is parsed, and some content from the user is
  used to initialize the different generator objects.

* A ``context`` is created. It contains the settings from the command line and
  a settings file if provided.
* The ``generate_context`` method of each generator is called, updating
  the context.
* The writer is created and given to the ``generate_output`` method of each
  generator.

I make two calls because it is important that when the output is generated by
the generators, the context will not change. In other words, the first method
``generate_context`` should modify the context, whereas the second
``generate_output`` method should not.

Then, it is up to the generators to do what the want, in the
``generate_context`` and ``generate_content`` method. Taking the
``ArticlesGenerator`` class will help to understand some others concepts. Here
is what happens when calling the ``generate_context`` method:

* Read the folder “path”, looking for restructured text files, load each of
  them, and construct a content object (``Article``) with it. To do so, use
  ``Reader`` objects.
* Update the ``context`` with all those articles.

Then, the ``generate_content`` method uses the ``context`` and the ``writer``
to generate the wanted output.
